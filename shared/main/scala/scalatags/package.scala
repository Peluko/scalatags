import scala.collection.immutable.Queue
import scala.collection.{SortedMap, mutable}

/**
 * ScalaTags is a small XML/HTML construction library for Scala. See
 * [[https://github.com/lihaoyi/scalatags the Github page]] for an introduction
 * and documentation.
 */
package object scalatags {

  /**
   * Convenience object to help import all [[Tags]], [[Attrs]], [[Styles]] and
   * [[Datatypes]] into the global namespace via `import scalatags.all._`
   */
  object all extends Attrs with Styles with Tags with DataConverters
  /**
   * Convenience object to help import all [[Tags]], and [[DataConverters]], while
   * aliases [[Attrs]] as `attr` and [[Styles]] as `css`. Used via
   * `import scalatags.short._`
   */
  object short extends Tags with DataConverters{
    object * extends Attrs with Styles
  }
  /**
   * Mark the given string as "raw", meaning it will not get escaped when the
   * Scalatags fragment is serialized. This makes it easy to open up XSS holes
   * and other vulnerabilities, but is sometimes necessary and useful.
   */
  def raw(s: String) = new RawNode(s)

  /**
   * Allows you to modify a HtmlTag by adding a String to its list of children
   */
  implicit def stringNode(v: String) = new StringNode(v)


  /**
   * Allows you to modify a [[HtmlTag]] by adding a Seq containing other nest-able
   * objects to its list of children.
   */
  implicit class SeqModifier[A <% Modifier](xs: Seq[A]) extends Modifier{
    def transform(tag: HtmlTag) = {
      var t = tag
      for(x <- xs) t = x.transform(t)
      t
    }
  }

  /**
   * Provides extension methods on strings to fit them into Scalatag fragments.
   */
  implicit class ExtendedString(s: String){
    /**
     * Converts the string to a [[HtmlTag]]
     */
    def tag = {
      if (!Escaping.validTag(s))
        throw new IllegalArgumentException(
          s"Illegal tag name: $s is not a valid XML tag name"
        )
      HtmlTag(s, Nil, SortedMap.empty)
    }
    /**
     * Converts the string to a void [[HtmlTag]]; that means that they cannot
     * contain any content, and can be rendered as self-closing tags.
     */
    def voidTag = {
      if (!Escaping.validTag(s))
        throw new IllegalArgumentException(
          s"Illegal tag name: $s is not a valid XML tag name"
        )
      HtmlTag(s, Nil, SortedMap.empty, void=true)
    }
    /**
     * Converts the string to a [[UntypedAttr]]
     */
    def attr = {
      if (!Escaping.validAttrName(s))
        throw new IllegalArgumentException(
          s"Illegal attribute name: $s is not a valid XML attribute name"
        )
      UntypedAttr(s)
    }
    /**
     * Converts the string to a [[TypedAttr]]
     */
    def attrTyped[T] = {
      if (!Escaping.validAttrName(s))
        throw new IllegalArgumentException(
          s"Illegal attribute name: $s is not a valid XML attribute name"
        )
      TypedAttr[T](s)
    }
    /**
     * Converts the string to a [[UntypedStyle]]. The string is used as the cssName of the
     * style, and the jsName of the style is generated by converted the dashes
     * to camelcase.
     */
    def style = UntypedStyle(camelCase(s), s)
    /**
     * Converts the string to a [[TypedStyle]].
     * The string is used as the cssName of the style, and the
     * jsName of the style is generated by converted the dashes to camelcase.
     */
    def styleTyped[T] = TypedStyle[T](camelCase(s), s)
    /**
     * Converts the string to a CSS [[Cls]] object.
     */
    def cls = new Cls(s)
  }
  private[scalatags] def camelCase(dashedString: String) = {
    val first :: rest = dashedString.split("-").toList

    (first :: rest.map(s => s(0).toUpper.toString + s.drop(1))).mkString
  }
}
